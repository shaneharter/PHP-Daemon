#!/usr/bin/php
<?php
/**
 * A simple console that lets you view and interact with a shared memory address
 * Use the shortcut $addresses array to store commonly-attached memory addresses
 * @author Shane Harter
 */


// Memory addresses are generated by the daemon using the current path of the daemon and the name of the worker alias
// As long as those things stay the same the address will stay the same, so you can save them here as shortcuts.
$addresses = array(
    'PrimeNumbers'    =>  1342185173,
    'GetFactors'      =>  1191190231,
    'LongPoll_API'    =>  1090519102,
);

declare(ticks = 5);
register_signal_handlers();

$index = array_keys($addresses);
$string = '';
foreach($index as $id => $key) {
    $string .= sprintf('%s [-%s] %s%s%s', PHP_EOL, $id, $key, "\t", $addresses[$key]);
}

echo PHP_EOL, "PHP Simple Daemon - Shared Memory Console";
echo PHP_EOL, "Enter Shared Memory Address";
if ($string)
    echo " or Select a Shortcut:", $string;
echo PHP_EOL;
echo PHP_EOL, "Hint: To determine the address used by a worker, send a `10` signal to your daemon. It will be a 10 digit number beside the worker's alias";
echo PHP_EOL;
echo PHP_EOL;


stream_set_blocking(STDIN, 0);
$address        = false;
$input          = '';
$macro_input    = '';
$prompt         = true;
$header_exists  = true;
$flash          = '';
$interrupt      = false;

while(true) {

    if ($interrupt && $macro_input) {
        $macro_input = '';
        $prompt = true;
        $interrupt = false;
        echo PHP_EOL;   // If the interrupt was sent via ctrl-c it'll put a ^C in the terminal
    }

    if ($interrupt) {
        break;
    }

    $flash = '';

    // Every few iterations check to see if the header still exists (if not the memory block
    // has probably been detached and released by the daemon) If the header didn't exist when the memory
    // was attached just skip the check and let the user figure out if the memory is detached.
    if (!$macro_input && $address && $header_exists && ($input || mt_rand(1,3) == 2) && !shm_has_var($shm, 1)) {
        out("Shared Memory Block {$address} Has Been Released");
        $prompt = true;
        $address = false;
        @shm_detach($shm);
        $shm = null;
        if (!$input)
            echo PHP_EOL;
    }

    if ($input || $prompt)
        if (!$address)
            echo "ADDR > ";
        else
            echo "ID > ";

    $prompt = false;
    if ($macro_input) {
        $input = $macro_input;
        $macro_input = '';
    } else {
        $input  = strtolower(fgets(STDIN));
    }

    $prompt = $input == "\n";
    $input  = trim($input);

    try {

        switch(true) {
            case empty($input):
                continue;

            case $address && input('exit'):
                @exec("rm -f /tmp/shm_{$address}_*");
                exit;

            case input('exit'):
                exit;

            case $address && input('help'):

                $out = array();
                $out[] = '';
                $out[] = 'Available Commands:';
                $out[] = 'exit';
                $out[] = 'help                Display this help';
                $out[] = 'addr [integer]      Display an ADDR prompt to enter a new Address, and optionally pass an Address to switch directly to';
                $out[] = '[integer]           A valid memory address';
                $out[] = 'scan                Scan the shared memory block for items currently in-memory';
                $out[] = 'watch               Watch the shared memory block and log all Additions, Removals and Updates - Use [Enter] to break a Watch.';
                $out[] = 'rewatch             Pick-up a previous Watch where you left-off';
                $out[] = '';

                out(implode(PHP_EOL, $out));
                continue;

            case input('help'):
                $out = array();
                $out[] = '';
                $out[] = 'Available Commands:';
                $out[] = 'exit';
                $out[] = 'help                Display this help';
                $out[] = '[integer]           A valid memory address';
                $out[] = '';
                $out[] = 'Shortcuts:';
                $out[] = $string;
                $out[] = '';
                $out[] = 'Shortcuts come from the $addresses array. Add your own shortcuts to make life easier.';
                $out[] = '';

                out(implode(PHP_EOL, $out));
                continue;

            case input('addr'):
                if ($address) {
                    out("Releasing Address...");
                    $address = false;
                    @shm_detach($shm);
                }
                macro(1, $input);
                continue;

            case $address && input('scan'):
                $out = '';
                for ($i=0; $i<100000; $i++)
                    if(shm_has_var($shm, $i))
                        $out .= " $i";

                out("Keys In Use:");
                if ($out)
                    out($out);
                else
                    out("None");
                continue;

            case $address && input('watch'):
                // Watch resets the registry (which is used to compare the snapshot to)
                // You can interrupt a Watch by pressing enter and then re-enter it by using rewatch
                // Important to note that the iterative polling technique used here only works acceptably well because
                // we know the characteristics of the way the Mediator uses shared memory: Numeric, monotonically increasing keys
                out("\nWatching Shared Memory..");
                out("Note: The `watch` command uses polling to determine changes. Changes made in between polling iterations will not be logged.\n");
                $registry = array();
                $max = 1;

            case $address && input('rewatch'):
                $snapshot = array();
                $statuses = array();

                // Build a Snapshot
                for ($i=0; $i<$max+1000; $i++) {
                    if(shm_has_var($shm, $i)) {
                        $x = shm_get_var($shm, $i);
                        if (is_object($x) && isset($x->status))
                            $statuses[$i] = $x->status;
                        $snapshot[$i] = md5(print_r($x, true));
                        if ($i > $max)
                            $max = $i;
                        $x = null;
                    }
                }

                // Compare to Array
                $removed = array_diff_key($registry, $snapshot);
                foreach(array_keys($removed) as $item)
                    out("Item {$item} Removed");

                $added = array_diff_key($snapshot, $registry);
                foreach(array_keys($added) as $item)
                    if (isset($statuses[$item]))
                        out ("Item {$item} Added at Status " . $statuses[$item]);
                    else
                        out ("Item {$item} Added");

                foreach(array_diff_key($registry, $removed) as $item => $hash)
                    if ($hash != $snapshot[$item])
                        if (isset($statuses[$item]))
                            out ("Item {$item} Updated at Status " . $statuses[$item]);
                        else
                            out ("Item {$item} Updated");

                $registry = $snapshot;
                macro(3);
                continue;

            case $address && is_numeric($input) && $input > 0:
                out("Shared Memory Contents:");
                if (!shm_has_var($shm, $input)) {
                    out("Null");
                    continue;
                }

                $contents = print_r(shm_get_var($shm, $input), true);
                $sizeof = strlen($contents);
                $cutoff = 1024 * 1.5;
                if ($sizeof > $cutoff) {
                    $filename = "/tmp/shm_{$address}_{$input}";
                    $sizeof = number_format($sizeof, 0);
                    if (file_put_contents($filename, $contents)) {
                        out("Contents too big for console; Redirected {$sizeof} bytes to {$filename}");
                        out("Note: The file(s) will be removed when you `exit` this console");
                        continue;
                    }

                    out("Contents too big for console but output redirection to '{$filename}' failed.");
                    out("Displaying the first 1024 bytes (of {$sizeof} bytes total)");
                }

                out(substr($contents, 0, $cutoff));
                continue;

            case !$address && $input <= 0 && isset($index[abs($input)]):
                $key = $index[abs($input)];
                macro(2, $addresses[$key]);
                out("Setting Address From Shortcut: " . $key);
                continue;

            case !$address && is_numeric($input) && $input > 0:
                $address = $input;
                $shm = shm_attach($input);
                $header_exists = true;
                out("Address {$input} Attached");

                // If no header is written the memory can still be attached but warn them just in case they typo'd or something
                if (!shm_has_var($shm, 1)) {
                    $header_exists = false;
                    out("Note: This shared memory address appears uninitilized: No header has been written.");
                }
                continue;

            case $address:
                throw new Exception("Invalid Key");

            default:
                throw new Exception('Invalid Input: Valid Address or Shortcut Required');
        }

    }
    catch(Exception $e)
    {
        echo $e->getMessage(), PHP_EOL, PHP_EOL;
    }

    usleep(20 * 1000);
}

echo PHP_EOL;


function out($out)
{
    global $flash;
    if ($flash) {
        echo $flash, PHP_EOL;
        $flash = '';
    }

    echo $out, PHP_EOL;
}

function macro($id) {
    global $input, $macro_input, $prompt, $addresss;
    if ($macro_input)
        $macro_input = '';

    switch($id){
        case 1:
            // Macro 1 reads an optional Address from a address-reset command.
            // Example:   ID > addr 12345    The current address will be released and this macro will pull 12345 out and set
            //                               it as the new address.
            $arg = @func_get_arg(1);
            if (!$arg || strlen(trim($arg)) < 4)
                return;

            $macro_input = trim(str_replace('addr', '', $arg));
            break;

        case 2:
            // Macro 2 takes a saved address from the addresses array and reads it into $input
            $arg = @func_get_arg(1);
            if (!$arg || !is_numeric($arg))
                return;

            $macro_input = $arg;
            break;

        case 3:
            usleep(30 * 1000);
            if (fgets(STDIN) == "\n")
                return;

            $macro_input = 'rewatch';
            break;
    }

    if ($macro_input)
        $input = '';
}

function input($command, $in = null, Array $candidates = array('scan', 'addr', 'watch', 'rewatch', 'help', 'exit')) {
    global $input, $flash;
    if (empty($in))
        $in = $input;

    if (empty($in))
        return null;

    $in = substr($in, 0, strlen($command));
    $matches = array();
    foreach ($candidates as $candidate)
        if ($in == substr($candidate, 0, strlen($in)))
            $matches[] = $candidate;

    if (count($matches) > 1)
        out("Ambiguous Command. Matches: " . implode(', ', $matches));

    if (count($matches) && $matches[0] == $command) {
        if ($in != $matches[0])
            $flash = $matches[0];

        return true;
    }

    return false;
}

function register_signal_handlers() {
    $signals = array(
        SIGTERM, SIGINT, SIGHUP
    );

    foreach(array_unique($signals) as $signal) {
        pcntl_signal($signal, 'signal');
    }
}

function signal($signal) {
    global $address, $shm, $interrupt;
    switch($signal) {
        case SIGINT:
        case SIGTERM:
            $interrupt = true;
            break;

        case SIGHUP:
            if ($address) {
                $shm = shm_attach($address);
            }
            break;
    }
}